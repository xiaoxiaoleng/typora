# Redis

- 为什么单实例 但依然很快

  ```
  1、存内存操作
  2、单线程避免频繁上下文操作
  3、采用非阻塞I/O多路复用
  ```

- 数据类型

  ```
  1、String
  2、hash 结构化对象
  3、list 可以简单的做消息队列
  4、set 存放不重复值几何
  5、sorted set 几何中的元素可以进行排列
  ```

- redis过期策略以及内存淘汰机制

  ```
  1、定期删除
  
  2、惰性删除
  ```

- redis和数据库双写一致性问题

  ```
  数据库和缓存双写，就必然会存在不一致的问题.如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。
  首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。	
  ```

- 缓存穿透与雪崩问题

  ```
  （一）、穿透
    1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
    2、采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
    3、提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。
  （二）、缓存雪崩
  	 1、给缓存的失效时间，加上一个随机值，避免集体失效。
  	 2、使用互斥锁，但是该方案吞吐量明显下降了。
  	 3、双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点
  		a)、从缓存A读数据库，有则直接返回
  		b)、A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。
      c)、更新线程同时更新缓存A和缓存B
   
  ```

  